/*************************************
文件名： client.c 
linux 下socket网络编程简例  - 客户端程序
服务器端口设为 0x8888   （端口和地址可根据实际情况更改，或者使用参数传入）
服务器地址设为 192.168.1.104
作者:kikilizhm#163.com (将#换为@)
*/

#include <stdlib.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <string.h>

#include <inttypes.h>

////////////////////////////////////////////////////////////

#define KEY_ROOT 	"/home/jauntezhou/Documents/data/"
#define KEY_ROOT_LEN 	strlen(KEY_ROOT)
#define KEY_SIZE 	16

#define KEY_REQ_TYPE 	1

#define FN_MAX 		128
#define UN_MAX 		128
#define KEY_REQ_MAX 	1+1+1+FN_MAX+UN_MAX


#define KEY_RES_TYPE 	2

#define KEY_MAX 	128
#define KEY_RES_MAX 	1+1+KEY_MAX


typedef struct KEY_REQUEST{
	uint8_t type;
	uint8_t un_len;
	uint8_t fn_len;
	char buf[FN_MAX+UN_MAX];
}KeyReq_T;

typedef struct KEY_RESPONSE{
	uint8_t type;
	uint8_t key_len;
	unsigned char key[KEY_MAX];
}KeyRes_T;

////////////////////////////////////////////////////////////



int main()
{
	int cfd;
	int sin_size;
	ssize_t ret;

	KeyReq_T *req;
	ssize_t req_len;
	KeyRes_T *res;
	//ssize_t res_len;
	unsigned char *key;

	//char buffer[1024]={0};    /* 接受缓冲区 */
	struct sockaddr_in s_add,c_add; /* 存储服务端和本端的ip、端口等信息结构体 */
	unsigned short portnum=0x8882;  /* 服务端使用的通信端口，可以更改，需和服务端相同 */

	printf("Hello,welcome to client !\r\n");

	/* 建立socket 使用因特网，TCP流传输 */
	cfd = socket(AF_INET, SOCK_STREAM, 0);
	if( -1 == cfd ){
		printf("socket fail ! \r\n");
		return -1;
	}
	printf("socket ok !\r\n");

	/* 构造服务器端的ip和端口信息，具体结构体可以查资料 */
	bzero(&s_add,sizeof(struct sockaddr_in));
	s_add.sin_family=AF_INET;
	/* ip转换为4字节整形，使用时需要根据服务端ip进行更改 */
	s_add.sin_addr.s_addr= inet_addr("127.0.0.1");
	/* 这里htons是将short型数据字节序由主机型转换为网络型 */ 
	s_add.sin_port=htons(portnum);

	/* 这里打印出的是小端和我们平时看到的是相反的。 */
	printf("s_addr = %#x ,port : %#x\r\n",s_add.sin_addr.s_addr,s_add.sin_port); 


	/* 客户端连接服务器，参数依次为socket文件描述符，地址信息，地址结构大小 */
	ret = connect(cfd,(struct sockaddr *)(&s_add), sizeof(struct sockaddr));
	if( -1 == ret ){
		printf("connect fail !\r\n");
		return -1;
	}
	printf("connect ok !\r\n");
	

	//////////////////////////////////////////////
	char *user_name;
	user_name = (char *)malloc(10);
	strcpy(user_name, "JaunteZhou");		
	char *file_name;
	file_name = (char *)malloc(10);
	strcpy(file_name, "data01.txt");

	printf("user_name : %s\n0000", user_name);
	//////////////////////////////////////////////

	
	req = (KeyReq_T *)malloc(KEY_REQ_MAX);
	memset( (unsigned char *)req, 0, KEY_REQ_MAX );

	req->type = KEY_REQ_TYPE;
	req->un_len = strlen( user_name );
	req->fn_len = strlen( file_name );
	strcpy( req->buf, user_name );
	strcpy( req->buf+req->un_len, file_name );

	req_len = 1+1+1+ strlen(user_name) + strlen(file_name);

	/* 这里使用write向客户端发送信息，也可以尝试使用其他函数实现 */
	ret = write( cfd, (unsigned char *)req, req_len );
	if(-1 == ret || req_len != ret){
		printf("write req to server fail!\r\n");
		return -1;
	}
	printf("write ok!\r\n");

	/////////////////////////////////////////////////
	free(user_name);
	free(file_name);
	user_name = NULL;
	file_name = NULL;
	/////////////////////////////////////////////////

	free(req);
	req = NULL;


	res = (KeyRes_T *)malloc(KEY_RES_MAX);
	memset( (unsigned char *)res, 0, KEY_RES_MAX );

	key = (unsigned char *)malloc(KEY_SIZE);
	memset( key, 0, KEY_SIZE);

	/*连接成功,从服务端接收字符*/
	ret = read(cfd, (unsigned char *)res, KEY_RES_MAX);
	if( -1 == ret ){
		printf("read data fail !\r\n");
		return -1;
	}
	if( KEY_RES_TYPE != res->type ){
		printf("read data fail !!!\r\n");
		return -1;
	}
	printf("read ok\r\nREC:\r\n");

	strncpy( key, res->key, res->key_len);

	printf("%s\r\n000",key);

	/////////////////////////////////////////////////////////
	unsigned char *tmp;
	tmp = (unsigned char *)malloc(KEY_SIZE);
	memset(tmp, 0, KEY_SIZE);
	strncpy(tmp, "JaunteZhou10502", 15);
	
	ret = strcmp(key, tmp);
	if( ret != 0 ) {
		printf("Key Not Right !\n");
		return -1;
	}
	printf("Key Right !\n");
	/////////////////////////////////////////////////////////////////////

	free(res);
	free(key);
	res = NULL;
	key = NULL;

	getchar(); /* 此句为使程序暂停在此处，可以使用netstat查看当前的连接 */
	close(cfd); /* 关闭连接，本次通信完成 */

	return 0;
}

